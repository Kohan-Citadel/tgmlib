//------------------------------------------------
//--- 010 Editor v14.0 Binary Template
//
//      File: 
//   Authors: 
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: *.TGM
//  ID Bytes: 
//   History: 
//------------------------------------------------

BitfieldDisablePadding();
ThemeAutoScaleColors(false);
local ubyte write_log = false;
if (write_log == true) {
    local int fh = FileNew("Text");
};
local uint offset = 12;  // to account for FORM chunk

typedef uint32 BOOL <read=BOOLRead, write=BOOLWrite>;

string BOOLRead( BOOL b ) {
    if (b) {
        return "true";
    }
    return "false";
}

void BOOLWrite( BOOL &b, string s ) {
    if( s == "true" ) {
        b = (BOOL)1;
    } else if( s == "false") {
        b = (BOOL)0;
    }
}

typedef struct {
    float se;
    float sw;
} HOTSPOT;

// represents a single technology in a player section in the TECH chunk
typedef struct {
    uint32 name_len;
    char tech_name[name_len];
} TECHNOLOGY <optimize=false>;

// represents a player's technologies in the TECH chunk
typedef struct {
    uint32 player_number;  // This is 0-indexed
    uint32 num_techs;  // Number of known technologies
    TECHNOLOGY known_techs[num_techs];
} PLYR_TECH <optimize=false>;
    
typedef struct {
    char chunk_name[4];  // Always FORM
    BigEndian();
    int32 length <fgcolor=0x3C8E38>;  //length in bytes from start of HEDR to end of file
    LittleEndian();
    char file_type[4];  // TGSV for .TGM
} FORM_CHUNK;

typedef struct {
    char chunk_name[4];
    BigEndian();
    uint32 chunk_length <fgcolor=0x3C8E38>;
    LittleEndian();
    int required <fgcolor=cDkRed>; // Seems to be 0400 0300 across maps
    char null[4] <fgcolor=cDkGray>; // Can be safely zeroed
} HEDR_CHUNK;

typedef struct {
    char chunk_name[4];
    BigEndian();
    uint32 chunk_length <fgcolor=0x3C8E38>;
    LittleEndian();
    local int start_pos = FTell();
    byte required <fgcolor=cDkRed>; // must be at least 0x01 or the map size won't display in custom scenario
                                     // and no more than 0x0C or the map won't load
    char null0[7] <fgcolor=cDkGray>;  // Seems to always be 0x 00 0000 0401 0000
    char game_version[12] <fgcolor=cDkGray>;  // This doesn't seem to be used anywhere, though perhaps prevents outdated games from loading it?
    char null1[chunk_length + start_pos - FTell()] <fgcolor=cDkGray>;
} GVER_CHUNK;

typedef struct {
    char chunk_name[4];
    BigEndian();
    uint32 chunk_length <fgcolor=0x3C8E38>;
    LittleEndian();
    int required <fgcolor=cDkRed>; // needs to be 0x06 (0x05 in some KIS maps)
    ubyte name_len;
    char map_name[name_len];
    ubyte desc_len;
    char map_description[desc_len];
    uint size_se;
    uint size_sw;
    int deathmatch_teams;
    char unknown2[8] <fgcolor=cDkGray>;
    int custom_play_kingdoms;
    char unknown3[4] <fgcolor=cDkGray>;
    int scenario_deathmatch_kingdoms;
    char unknown4[4] <fgcolor=cDkGray>;
    
    
    struct KINGDOM {
        uint is_active;  // 0x01 for active
        ubyte name_len;
        char player_name[name_len];
        char unknown[4];  // Seems to always be null
        uint32 team;  // 0-indexed, will be 0xFFFFFFFF if set to 'custom'
        ubyte SAIe_len;
        char SAI_easy[SAIe_len];
        ubyte SAIm_len;
        char SAI_medium[SAIm_len];
        ubyte SAIh_len;
        char SAI_hard[SAIh_len];
    } kingdoms[8] <optimize=false>;

    struct TEAM {
        char unknown[4];
        ubyte name_len;
        char name[name_len];
        char unknown2[12];
    } teams[4] <optimize=false>;
    
    char unknown5[84];
    
    struct PLYR_PROF {
        ubyte name_len;
        char sai_name[name_len];
        byte unknown[4];
        uint32 faction;
        uint32 team;  //  0xFFFFFFFF is No Team/Custom
        byte unknown1[4];
    } players[8] <optimize=false>;
    char unknown6[12];
    float starting_gold;
    int u1;
    BOOL use_politics;
    byte b1;
    BOOL allow_settlements;
    BOOL allow_outposts;
    int max_companies;
    int max_settlement;
    int max_outpost;
    byte padding[28];
    int allied_victory; // 0: alliance or single; 1: single only; 2: alliance only
    byte unknown7[50];
} EDTR_CHUNK;

typedef struct {
    char chunk_name[4];
    BigEndian();
    uint32 chunk_length <fgcolor=0x3C8E38>;
    LittleEndian();
    int null0 <fgcolor = cDkGray>;
    struct MAP_SIZE {
        int se;
        int sw;
    } size;
    byte null1[chunk_length - sizeof(null0) - sizeof(size)] <fgcolor = cDkGray>;  // Map editor data stats, can be safely zeroed 
} MPST_CHUNK;

typedef struct {
    char chunk_name[4];
    BigEndian();
    uint32 chunk_length <fgcolor=0x3C8E38>;
    LittleEndian();
    int required <fgcolor=cDkRed>;  // must be 0x0500 0000 
    typedef struct {
        BigEndian();
        uint16 terrain1: 4;
        uint16 terrain2: 4;
        uint16 display: 4;
        uint16 layout: 4;
        BigEndian();
    } GRID_TILE <optimize=false>;
    GRID_TILE tiles[EDTR.size_se*EDTR.size_sw];
} MGRD_CHUNK;

typedef struct {
    char chunk_name[4];
    BigEndian();
    uint32 chunk_length <fgcolor=0x3C8E38>;
    LittleEndian();
    int null <fgcolor=cDkGray>;  // can be anything other than 1 (0-size unit overlay buffer error), doesn't seem to have effect otherwise. Defaults to 2
} RADR_CHUNK;

typedef struct {
    char chunk_name[4];
    BigEndian();
    uint32 chunk_length <fgcolor=0x3C8E38>;
    LittleEndian();
    local int start_pos = FTell();
    int load <fgcolor=cDkRed>;  //  must be set to 2, or FTRS chunk is skipped by map editor
    typedef struct {
        byte header[2];
        uint16 index;
        uint32 editor_id;
        HOTSPOT pos;
        BigEndian();
        short flag;  // 0x092F if no additional data
        LittleEndian();
        if (flag == 0x090F) {
            byte more_data[4] <fgcolor=cDkGray>;  // Can be deleted and feature still works as expected
        }
    } FEATURE <comment=FeatureComment>;
    while (FTell() < start_pos + chunk_length) {
        FEATURE features;
    }
} FTRS_CHUNK;

string FeatureComment(FEATURE &f) {
    if (f.index == 0xFFFF) {
        return "Chunk Padding";
    }
    return Str("%s",TYPE.objects[f.index].name);
}

typedef struct {
    char chunk_name[4];
    BigEndian();
    uint32 chunk_length <fgcolor=0x3C8E38>;
    LittleEndian();
    int count <fgcolor=0x3C8E38>;  // Number of features
    int feature_sizes[count];  // Size of each feature in bytes
} FIDX_CHUNK;

// Only used in campaign saved games
typedef struct{
    char chunk_name[4];
    BigEndian();
    uint32 chunk_length <fgcolor=0x3C8E38>;
    LittleEndian();
} CMPG_CHUNK;

typedef struct {
    char chunk_name[4];
    BigEndian();
    uint32 chunk_length <fgcolor=0x3C8E38>;
    LittleEndian();
    char padding[4];
    PLYR_TECH player_techs[8];
} TECH_CHUNK;

typedef struct {
    char chunk_name[4];
    BigEndian();
    uint32 chunk_length <fgcolor=0x3C8E38>;
    LittleEndian();
    local int start_pos = FTell();
    int first_id;
    int next_id;  // id to be assigned to next object
    short ids[0x8000];  // 0xFFFF if unused, 0x0000 if used
    int total_ids;
    byte obj_flags[start_pos + chunk_length - FTell()];
} GAME_CHUNK;

typedef struct {
    char chunk_name[4];
    BigEndian();
    uint32 chunk_length <fgcolor=0x3C8E38>;
    LittleEndian();
    int32 three;
    uint32 elapsed_ticks;
    float tick_rate;
} SIM_CHUNK;

typedef struct {
    char chunk_name[4];
    BigEndian();
    uint32 chunk_length <fgcolor=0x3C8E38>;
    LittleEndian();
    byte data[chunk_length];
} MMGR_CHUNK;

typedef struct {
    char chunk_name[4];
    BigEndian();
    uint32 chunk_length <fgcolor=0x3C8E38>;
    LittleEndian();
    local int start_pos = FTell();
    int i0;
    typedef struct {
        byte name_len;
        char name[name_len];
        ushort s1;
        int i1;
        int i2;
        int i3;
        int i4;
        int i5;
        int i6;
    } HERO;
    
    while (start_pos + chunk_length > FTell() + 22) {
        HERO heroes;
    }
} HROS_CHUNK;    
    
typedef struct {
    char chunk_name[4];
    BigEndian();
    uint32 chunk_length <fgcolor=0x3C8E38>;
    LittleEndian();
    char unknown[2];
    uint16 num_objs;  // The number of objects in the chunk
    struct TYPE_OBJ {
        char name[32];
        byte sub_type;
        byte type;
        if (write_log) {
            FPrintf(fh, "%s,%i,%i\n", name, type, sub_type);
        }; 
    } objects[num_objs] <optimize=false, comment=Str("%s", this.name)>;
} TYPE_CHUNK;

typedef struct {
    char chunk_name[4];
    BigEndian();
    uint32 chunk_length <fgcolor=0x3C8E38>;
    LittleEndian();
    byte unknown[4];
    struct PLR_OBJ {
        local int start_pos = FTell();
        uint32 uknwn;
        byte unknown[8];  // always seems to be 0x1400 0000 0F00 0000
        char player_name[15];  // 14 characters and null terminated
        byte faction;  // 0x01 for Nationalist, 0x02 for Royalist, 0x03 for Council, 0x04 for Ceyah
        byte unknown2[7];
        float starting_gold;
        int unknown3;
        BigEndian();
        byte sai_len;
        LittleEndian();
        char sai_name[sai_len];
        if (player_name == "Independent") {
            FSeek(start_pos + 4592);
        } else {
            FSeek(start_pos+4597);
        }
        // There is a ton more data after this,
        // and apparently no pointer to the next section
        // so just search for 0x1400 0000 0F00 0000 and pray lol
        //local uchar search[8] = {20,0,0,0,15,0,0,0};
        //FSeek(FTell()+4096);
        //FSeek(FindFirst("140000000F000000,h", true, false, 0, 0.0, 1, FTell()));
        //FSeek(FTell() - 4);
        // Players in games that haven't been playen (maps, not save games)
        // are 4597 bytes long. So just jump to the next one
        
    } PLR[9] <optimize=false>;
} PLRS_CHUNK;

typedef struct {
    byte uk0;  // 0x24 for building, 0x44 for company
    byte player;  // 0-indexed player number of owner
    uint16 index <comment=Str("%s",TYPE.objects[this].name)>;  // index of object in TYPE list
    uint32 id;  // ID shown in editor
    HOTSPOT hotspot;
    char name[20];  // fixed length and null terminated
    byte flag1;
    byte flag2;  // equals 0x0D if structure is at a different HP than specified in INI
    if (flag2 == 13) {
        float current_hp;
    } else if (flag2 == 7) {  // 0x07 for spider lair in bonehenge
        byte unknown_data;
    }
    char unknown1[12];
    ubyte status <comment=ObjStatusComment>;
    float uk1;
    uint16 pos_se;
    uint16 pos_sw;
    // Amount currently being produced
    float net_gold_production <fgcolor=cBlack, bgcolor=0x00DCFC>;
    float net_stone_production <fgcolor=cYellow, bgcolor=0x707070>;
    float net_wood_production <fgcolor=cYellow, bgcolor=0x2A578B>;
    float net_iron_production <fgcolor=cYellow, bgcolor=0x505050>;
    float net_mana_production <fgcolor=cYellow, bgcolor=0xD27619>;
    char unknown2[1];
    float max_hp;
    char unknown0[4];
    float booty_value;
    
    typedef struct {
        char padding[5];
        float supply_zone;
        char unknown3[8];
        float militia_curr;
        float militia_regen;
        char unknown4[9];
        float guard_zone;
        char unknown5[5];
        uint16 militia_front <comment=Str("%s",TYPE.objects[this].name)>;
        uint16 militia_support <comment=Str("%s",TYPE.objects[this].name)>;
        byte company_size;
        byte name_len;
        char company_name[name_len];
        float militia_max;
    } MILITIA_DATA;
    
    // the rest of the data is dependent on object type
    switch(TYPE.objects[index].sub_type) {
        // ruins
        case 0:
            char unknown3[13];
            break;
        // all settlements
        case 1:
        case 5:
        case 6:
        case 7:
        case 8:
            MILITIA_DATA militia_data;
            char unknown6[10];
            
            // each base component is encoded by 1 bit, ordered from highest to lowest:
            // Wall (128), Library (64), Temple (32), Barracks (16), Market (8), Quarry (4), Blacksmith (2), Woodmill (1)
            struct COMP_LIST {
                BigEndian();
                int wall: 1;
                int library: 1;
                int temple: 1;
                int barracks: 1;
                int market: 1;
                int quarry: 1;
                int blacksmith: 1;
                int woodmill: 1;
                LittleEndian();
                
                local int count = wall + library + temple + barracks + market + quarry + blacksmith + woodmill;
            } component_list;
            
            char unknown7[4];
            int important0 <fgcolor=cDkRed>;  // Always seems to be 0x00FF FF00, something to do with structure state/status
            char unknown8[25] <fgcolor=cDkGray>;  // Can be safely zeroed
            int block_size_1 <fgcolor=0x3C8E38>;
            char block_1[block_size_1] <fgcolor=cDkGray>; // can be safely zeroed
            
            int important1;
            int is_long;  // seems to indicate whether this part is 13 or 20 bytes long
            if (is_long == 1) {
                char block_2[12];
            } else {
                char block_2[5];
            }
            struct COMPONENT {
                local float check_cost = ReadFloat();
                if (check_cost > 1.0) {
                    float gold_spent <fgcolor=cBlack, bgcolor=0x00DCFC>;
                }        
                int size <fgcolor=0x3C8E38>;
                char data[size] <fgcolor=cDkGray>;  // can be safely zeroed
            // +1 accounts for adtl blank component block
            } components[component_list.count+1] <optimize=false>;
            break;
        // outposts
        case 2:
            MILITIA_DATA militia_data;
            char unknown7[6];
            break;
        // lairs
        case 3:
            MILITIA_DATA militia_data;
            char unknown5[17];
            break;
        // mines
        case 4:
            char unknown7[26];
            // structure base amount
            float gold_production <fgcolor=cBlack, bgcolor=0x00DCFC>;
            float stone_production <fgcolor=cYellow, bgcolor=0x707070>;
            float wood_production <fgcolor=cYellow, bgcolor=0x2A578B>;
            float iron_production <fgcolor=cYellow, bgcolor=0x505050>;
            float mana_production <fgcolor=cYellow, bgcolor=0xD27619>;
            break;
        };

} MAP_OBJ <optimize=false,comment=Str("%s, %i %i", TYPE.objects[this.index].name, TYPE.objects[this.index].type, TYPE.objects[this.index].sub_type)>;

string ObjStatusComment(ubyte &status) {
    switch(status) {
        case 0:
            return "Normal";
        case 1:
            return "Constructing";
        case 2:
            return "Destroyed";
        case 3:
            return "Causes crash in SIM";
        case 4:
            return "Mining";
        case 6:
            return "Out of Supply";
        default:
            return "Unknow Status";
    }
}      

typedef struct {
    char chunk_name[4];
    BigEndian();
    uint32 chunk_length <fgcolor=0x3C8E38>;
    LittleEndian();
    local int start_pos = FTell();
    char unknown[4];
    while (FTell() < (start_pos + chunk_length - 18)) {
        MAP_OBJ obj;
    }
} OBJS_CHUNK;


typedef struct {
    char chunk_name[4];
    BigEndian();
    uint32 chunk_length <fgcolor=0x3C8E38>;
    LittleEndian();
    //char data[chunk_length];
} PLACEHOLDER_CHUNK;

local uchar chunk_name[4];
FSeek(0);
local int start_pos = 0;
while (!FEof()) {
    start_pos = FTell();
    ReadBytes(chunk_name, start_pos, 4);
    switch(chunk_name) {
        case "FORM": FORM_CHUNK FORM; FSeek(start_pos + 12); break;
        case "HEDR": HEDR_CHUNK HEDR; FSeek(start_pos + HEDR.chunk_length + 8); break;
        case "GVER": GVER_CHUNK GVER; FSeek(start_pos + GVER.chunk_length + 8); break;
        case "EDTR": EDTR_CHUNK EDTR; FSeek(start_pos + EDTR.chunk_length + 8); break;
        case "MPST": MPST_CHUNK MPST; FSeek(start_pos + MPST.chunk_length + 8); break;
        case "MGRD": MGRD_CHUNK MGRD; FSeek(start_pos + MGRD.chunk_length + 8); break;
        case "RADR": RADR_CHUNK RADR; FSeek(start_pos + RADR.chunk_length + 8); break;
        case "FTRS": FTRS_CHUNK FTRS; FSeek(start_pos + FTRS.chunk_length + 8); break;
        case "FIDX": FIDX_CHUNK FIDX; FSeek(start_pos + FIDX.chunk_length + 8); break;
        case "CMPG": CMPG_CHUNK CMPG; FSeek(start_pos + CMPG.chunk_length + 8); break;
        case "TECH": TECH_CHUNK TECH; FSeek(start_pos + TECH.chunk_length + 8); break;
        case "GAME": GAME_CHUNK GAME; FSeek(start_pos + GAME.chunk_length + 8); break;
        case "SIM ": SIM_CHUNK SIM; FSeek(start_pos + SIM.chunk_length + 8); break;
        case "MMGR": MMGR_CHUNK MMGR; FSeek(start_pos + MMGR.chunk_length + 8); break;
        case "TYPE": TYPE_CHUNK TYPE; FSeek(start_pos + TYPE.chunk_length + 8); break;
        case "HROS": HROS_CHUNK HROS; FSeek(start_pos + HROS.chunk_length + 8); break;
        case "PLRS": PLRS_CHUNK PLRS; FSeek(start_pos + PLRS.chunk_length + 8); break;
        case "OBJS": OBJS_CHUNK OBJS; FSeek(start_pos + OBJS.chunk_length + 8); break;
        
        default:
            PLACEHOLDER_CHUNK chunk;
            FSeek(FTell()+chunk.chunk_length);
            break;
    }
}
        
            
    